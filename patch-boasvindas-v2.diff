
diff --git a/script/migrate_add_last_welcome_at.sql b/script/migrate_add_last_welcome_at.sql
new file mode 100644
index 0000000..b1c0abc
--- /dev/null
+++ b/script/migrate_add_last_welcome_at.sql
@@ -0,0 +1,11 @@
+-- Migration: adiciona coluna para controle de boas-vindas
+-- Execute uma vez no MySQL (CLI ou client) ou via script que voc√™ j√° usa.
+-- Ajusta a tabela 'contatos' para marcar quando foi enviada a √∫ltima mensagem de boas-vindas.
+
+ALTER TABLE contatos
+  ADD COLUMN last_welcome_at DATETIME NULL;
+
+-- √çndice auxiliar para consultas por data
+CREATE INDEX idx_last_welcome ON contatos(last_welcome_at);
+
+-- Fim
diff --git a/src/utils/atendimento.js b/src/utils/atendimento.js
new file mode 100644
index 0000000..6f55c14
--- /dev/null
+++ b/src/utils/atendimento.js
@@ -0,0 +1,33 @@
+'use strict';
+/**
+ * Utilit√°rio para verificar se a empresa est√° em hor√°rio de atendimento.
+ * Considera dias (["seg","ter","qua","qui","sex"]) e intervalo de hora (HH:mm).
+ */
+function estaNoHorario(emp) {
+  let dias = [];
+  try { dias = JSON.parse(emp.dias_funcionamento || '[]'); } catch {}
+  const now = new Date();
+  const dia = now.toLocaleString('pt-BR', { weekday: 'short' }).slice(0, 3).toLowerCase(); // seg/ter/...
+  const inDia = dias.length ? dias.includes(dia) : true; // se n√£o configurou dias, considera todos
+
+  const toMin = (s) => {
+    const [H, M] = String(s || '08:00').split(':').map(Number);
+    return (H * 60) + M;
+  };
+  const nowMin = (now.getHours() * 60) + now.getMinutes();
+  const inHora = nowMin >= toMin(emp.horario_inicio || '08:00') && nowMin <= toMin(emp.horario_fim || '18:00');
+
+  return inDia && inHora;
+}
+
+module.exports = { estaNoHorario };
diff --git a/src/managers/SessionManager.js b/src/managers/SessionManager.js
index 1234567..89abcde 100644
--- a/src/managers/SessionManager.js
+++ b/src/managers/SessionManager.js
@@ -1,5 +1,7 @@
 'use strict';
 // ... (demais imports originais)
+const path = require('path');
+const { estaNoHorario } = require('../utils/atendimento');
 
 // Supondo que voc√™ tenha uma classe SessionManager que gerencia as sess√µes do Baileys
 // e que exista acesso ao pool do DB e ao socket.io via this.db e this.io.
@@ -20,6 +22,124 @@ class SessionManager {
   // ... (demais m√©todos originais)
 
   // Ap√≥s criar/obter a sess√£o 'sock', registramos o listener de mensagens recebidas:
   attachListeners(empresaId, sock) {
+    // Listener principal: intercepta mensagens recebidas do cliente e dispara o fluxo de boas-vindas + setores
+    sock.ev.on('messages.upsert', async ({ messages, type }) => {
+      if (!Array.isArray(messages)) return;
+      for (const m of messages) {
+        try {
+          const jid = m?.key?.remoteJid;
+          const fromMe = m?.key?.fromMe;
+          if (!jid || fromMe) continue; // ignora mensagens que n√≥s enviamos
+          if (!jid.endsWith('@s.whatsapp.net')) continue; // apenas contatos pessoais (evita grupos)
+
+          // 1) Buscar config da empresa
+          const [empRows] = await this.db.execute(
+            'SELECT nome, mensagens_padrao, msg_ausencia, welcome_media_url, welcome_media_type, horario_inicio, horario_fim, dias_funcionamento FROM empresas WHERE id = ?',
+            [empresaId]
+          );
+          const emp = empRows[0];
+          if (!emp) continue;
+
+          // 2) Buscar contato (ou criar) e checar last_welcome_at
+          const [contRows] = await this.db.execute(
+            'SELECT id, nome, last_welcome_at FROM contatos WHERE empresa_id = ? AND telefone = ?',
+            [empresaId, jid]
+          );
+          let contatoId;
+          let lastWelcomeAt = null;
+          if (contRows.length) {
+            contatoId = contRows[0].id;
+            lastWelcomeAt = contRows[0].last_welcome_at;
+          } else {
+            const [ins] = await this.db.execute(
+              'INSERT INTO contatos (empresa_id, telefone, status_atendimento, created_at) VALUES (?, ?, "ABERTO", NOW())',
+              [empresaId, jid]
+            );
+            contatoId = ins.insertId;
+          }
+
+          // 3) Persistir a mensagem do cliente no hist√≥rico e emitir para web
+          const textoCliente = m?.message?.conversation
+            || m?.message?.extendedTextMessage?.text
+            || '';
+
+          await this.db.execute(
+            'INSERT INTO mensagens (empresa_id, remote_jid, from_me, tipo, conteudo) VALUES (?, ?, 0, "texto", ?)',
+            [empresaId, jid, textoCliente]
+          );
+          this.io.to(`empresa_${empresaId}`).emit('nova_mensagem', {
+            remoteJid: jid, fromMe: false, tipo: 'texto',
+            conteudo: textoCliente, timestamp: Math.floor(Date.now() / 1000)
+          });
+
+          // 4) Decidir se envia boas-vindas (primeira vez ou ap√≥s 24h)
+          const precisaWelcome = (() => {
+            if (!lastWelcomeAt) return true;
+            const horas = (Date.now() - new Date(lastWelcomeAt).getTime()) / 3600000;
+            return horas >= 24; // reenvia se passaram 24h sem boas-vindas
+          })();
+
+          // 5) Se n√£o precisa boas-vindas, ainda assim interpretar escolha de setor (ex.: "1", "2", ...) e continuar
+          // Buscar setores para interpretar sele√ß√£o
+          const [setores] = await this.db.execute(
+            'SELECT id, nome, mensagem_saudacao, cor FROM setores WHERE empresa_id = ? ORDER BY ordem ASC, id ASC',
+            [empresaId]
+          );
+          const num = parseInt(textoCliente.trim(), 10);
+          if (!isNaN(num) && num >= 1 && num <= setores.length) {
+            const setorEscolhido = setores[num - 1];
+            // Transferir para a fila do setor
+            await this.db.execute(
+              'UPDATE contatos SET status_atendimento = "FILA", setor_id = ?, atendente_id = NULL WHERE empresa_id = ? AND telefone = ?',
+              [setorEscolhido.id, empresaId, jid]
+            );
+            const aviso = `üîÑ Transferido para setor: *${setorEscolhido.nome}*`;
+            await sock.sendMessage(jid, { text: aviso });
+            await this.db.execute(
+              'INSERT INTO mensagens (empresa_id, remote_jid, from_me, tipo, conteudo) VALUES (?, ?, 1, "sistema", ?)',
+              [empresaId, jid, aviso]
+            );
+            this.io.to(`empresa_${empresaId}`).emit('nova_mensagem', {
+              remoteJid: jid, fromMe: true, tipo: 'sistema',
+              conteudo: aviso, timestamp: Math.floor(Date.now() / 1000)
+            });
+            // N√£o precisa seguir enviando boas-vindas neste caso
+            continue;
+          }
+
+          if (!precisaWelcome) {
+            // J√° enviou boas-vindas h√° menos de 24h e n√£o houve sele√ß√£o de setor ‚Äî encerra aqui
+            continue;
+          }
+
+          // 6) Montar boas-vindas conforme hor√°rio
+          const inHorario = estaNoHorario(emp);
+          let boasVindasText = 'Ol√°! Seja bem-vindo(a).';
+          try {
+            const padrao = JSON.parse(emp.mensagens_padrao || '[]');
+            const msgBV = padrao.find(p => String(p.titulo || '').toLowerCase() === 'boasvindas');
+            if (msgBV?.texto) boasVindasText = msgBV.texto;
+          } catch {}
+          const ausenciaText = emp.msg_ausencia || 'Estamos fora do hor√°rio. Retornaremos assim que poss√≠vel.';
+
+          const listaSetoresTexto = setores.length
+            ? 'Setores dispon√≠veis:\n' + setores.map((s, i) => `${i + 1}) ${s.nome}`).join('\n')
+            : 'No momento, n√£o h√° setores cadastrados.';
+
+          const textoFinal = inHorario
+            ? `${boasVindasText}\n\n${listaSetoresTexto}\n\n*Responda com o n√∫mero do setor para continuar.*`
+            : `${ausenciaText}\n\n${listaSetoresTexto}`;
+
+          // 7) Enviar boas-vindas (texto + m√≠dia opcional)
+          await sock.sendMessage(jid, { text: textoFinal });
+          if (emp.welcome_media_url && emp.welcome_media_type) {
+            const filePath = path.join(process.cwd(), 'public', emp.welcome_media_url.replace(/^\\/+/, ''));
+            const type = String(emp.welcome_media_type).toLowerCase();
+            const msgSend =
+              (type === 'imagem') ? { image: { url: filePath }, caption: boasVindasText } :
+              (type === 'video')  ? { video: { url: filePath }, caption: boasVindasText } :
+              (type === 'audio')  ? { audio: { url: filePath } } :
+                                    { document: { url: filePath }, caption: boasVindasText };
+            await sock.sendMessage(jid, msgSend);
+          }
+
+          // 8) Persistir no hist√≥rico e emitir para web
+          await this.db.execute(
+            'INSERT INTO mensagens (empresa_id, remote_jid, from_me, tipo, conteudo) VALUES (?, ?, 1, "sistema", ?)',
+            [empresaId, jid, textoFinal]
+          );
+          this.io.to(`empresa_${empresaId}`).emit('nova_mensagem', {
+            remoteJid: jid, fromMe: true, tipo: 'sistema',
+            conteudo: textoFinal, timestamp: Math.floor(Date.now() / 1000)
+          });
+
+          // 9) Atualizar last_welcome_at
+          await this.db.execute(
+            'UPDATE contatos SET last_welcome_at = NOW() WHERE id = ?',
+            [contatoId]
+          );
+        } catch (e) {
+          console.error('[SessionManager] Boas-vindas erro:', e);
+        }
+      }
+    });
   }
 }
 
